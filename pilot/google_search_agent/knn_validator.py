# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import logging
from pathlib import Path
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import KNeighborsClassifier
from google.adk.tools import FunctionTool

logger = logging.getLogger(__name__)

# --- k-NN Model Setup ---

# Load the corpus from the JSON file
corpus_path = Path(__file__).parent / "mercedes_jargon_corpus.json"
with open(corpus_path, "r") as f:
    corpus_data = json.load(f)

# Extract texts and labels (ids) for the model
corpus_texts = [item["text"] for item in corpus_data]
corpus_labels = [item["id"] for item in corpus_data]

# Create and train the TF-IDF Vectorizer
vectorizer = TfidfVectorizer()
corpus_vectors = vectorizer.fit_transform(corpus_texts)

# Create and train the k-NN Classifier
# n_neighbors is set to 1 because we want to find the single most similar known-good text
knn = KNeighborsClassifier(n_neighbors=1)
knn.fit(corpus_vectors, corpus_labels)

logger.info("k-NN Validator model trained successfully on the Mercedes jargon corpus.")

# --- Validation Function and Tool ---

def validate_with_knn(text_to_validate: str) -> dict:
    """Validates a given text against a known-good corpus of Mercedes-Benz jargon using a k-NN model.

    Args:
        text_to_validate: The text generated by an LLM that needs to be validated.

    Returns:
        A dictionary containing the validation result, including a confidence score.
    """
    if not text_to_validate:
        return {"confidence": 0.0, "error": "Input text cannot be empty."}

    try:
        # Vectorize the input text using the same vectorizer
        text_vector = vectorizer.transform([text_to_validate])

        # Use the k-NN model to find the nearest neighbor and its distance
        # The distance is the confidence score. A smaller distance means higher confidence.
        distances, indices = knn.kneighbors(text_vector, n_neighbors=1)

        # The distance is a value between 0 and sqrt(2) for cosine similarity with TF-IDF.
        # We convert it to a confidence score from 0.0 to 1.0 where 1.0 is a perfect match.
        confidence = 1 - (distances[0][0] / 1.414) # Normalize distance to a confidence score
        
        # Clamp the confidence to be within [0, 1]
        confidence = max(0.0, min(1.0, confidence))

        nearest_doc_id = corpus_labels[indices[0][0]]
        logger.info(f"k-NN validation: Nearest document is '{nearest_doc_id}' with confidence {confidence:.2f}")

        return {"confidence": round(confidence, 2)}

    except Exception as e:
        logger.error(f"Error during k-NN validation: {e}")
        return {"confidence": 0.0, "error": str(e)}


# --- ADK FunctionTool --- 
knn_validation_tool = FunctionTool(
    func=validate_with_knn,
    description="Calculates a confidence score for a given text by comparing it to a corpus of verified technical jargon."
)
